use core::cmp::min;
use core::fmt::Debug;
use core::marker::PhantomData;
use core::mem::MaybeUninit;

#[cfg(all(feature = "alloc", not(feature = "std")))]
use alloc::{boxed::Box, vec::Vec};
#[cfg(feature = "std")]
use std::{boxed::Box, vec::Vec};

use arbitrary::{Arbitrary, Error as ArbitraryError, Unstructured};
use ufotofu_queues::fixed::Fixed;
use ufotofu_queues::Queue;
use wrapper::Wrapper;

use crate::local_nb::consumer::SyncToLocalNb;
use crate::local_nb::{BufferedConsumer, BulkConsumer, Consumer};
use crate::sync::consumer::{
    ConsumeOperation as SyncConsumeOperation, ConsumeOperations as SyncConsumeOperations,
    Scramble as SyncScramble,
};
use crate::sync::{
    BufferedConsumer as SyncBufferedConsumer, BulkConsumer as SyncBulkConsumer,
    Consumer as SyncConsumer,
};

/// Operations which may be called against a consumer.
#[derive(Debug, PartialEq, Eq, Arbitrary, Clone)]
pub enum ConsumeOperation {
    Consume,
    ConsumerSlots(usize),
    Flush,
}

/// A sequence of heap-allocated operations for determining the method call patterns that a `Scramble` wrapper subjects its inner consumer to. Intended to be [generated by a fuzzer](https://rust-fuzz.github.io/book/cargo-fuzz/structure-aware-fuzzing.html).
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConsumeOperations(Box<[ConsumeOperation]>);

impl ConsumeOperations {
    /// Checks that the operations contain at least one non-flush operation
    /// and that no more than 256 different operations are being allocated.
    pub fn new(operations: Box<[ConsumeOperation]>) -> Option<Self> {
        let mut found_non_flush = false;
        for operation in operations.iter() {
            if *operation != ConsumeOperation::Flush {
                found_non_flush = true;
                break;
            }
        }

        if found_non_flush && operations.len() <= 256 {
            Some(ConsumeOperations(operations))
        } else {
            None
        }
    }
}

impl<'a> Arbitrary<'a> for ConsumeOperations {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, ArbitraryError> {
        match Self::new(Arbitrary::arbitrary(u)?) {
            Some(ops) => Ok(ops),
            None => Err(ArbitraryError::IncorrectFormat),
        }
    }

    #[inline]
    fn size_hint(depth: usize) -> (usize, Option<usize>) {
        <Box<[ConsumeOperation]> as Arbitrary<'a>>::size_hint(depth)
    }
}

/// Convert a set of local, non-blocking operations into their synchronous
/// equivalents.
fn sync_from_local_nb(operations: ConsumeOperations) -> SyncConsumeOperations {
    let mut sync_operations = Vec::new();

    for operation in operations.0.iter() {
        match operation {
            ConsumeOperation::Consume => sync_operations.push(SyncConsumeOperation::Consume),
            ConsumeOperation::ConsumerSlots(amount) => {
                sync_operations.push(SyncConsumeOperation::ConsumerSlots(*amount))
            }
            ConsumeOperation::Flush => sync_operations.push(SyncConsumeOperation::Flush),
        }
    }

    SyncConsumeOperations(sync_operations.into_boxed_slice())
}

/// A `Consumer` wrapper that scrambles the methods that get called on a wrapped consumer, without changing the observable semantics. Unless it uncovers buggy behavior on the wrapped consumer, that is.
#[derive(Debug)]
pub struct Scramble<C, T, F, E>(SyncToLocalNb<SyncScramble<C, T, F, E>>);

impl<C, T, F, E> Scramble<C, T, F, E> {
    /// Create a new wrapper around `inner` that exercises the consumer trait methods of `inner` by cycling through the given `operations`. To provide this functionality, the wrapper must allocate an internal buffer of items, `capacity` sets the size of that buffer. Larger values allow for more bizarre method call patterns, smaller values consume less space (surprise!).
    pub fn new(inner: C, operations: ConsumeOperations, capacity: usize) -> Self {
        let sync_operations = sync_from_local_nb(operations);

        let scramble = SyncScramble::new(inner, sync_operations, capacity);

        Scramble(SyncToLocalNb(scramble))
    }

    fn advance_operations_index(&mut self) {
        self.0 .0.advance_operations_index()
    }
}

impl<C, T, F, E> AsRef<C> for Scramble<C, T, F, E> {
    fn as_ref(&self) -> &C {
        let inner = self.0.as_ref();
        inner.as_ref()
    }
}

impl<C, T, F, E> AsMut<C> for Scramble<C, T, F, E> {
    fn as_mut(&mut self) -> &mut C {
        let inner = self.0.as_mut();
        inner.as_mut()
    }
}

impl<C, T, F, E> Wrapper<C> for Scramble<C, T, F, E> {
    fn into_inner(self) -> C {
        let inner = self.0.into_inner();
        inner.into_inner()
    }
}

impl<C, T, F, E> Consumer for Scramble<C, T, F, E>
where
    C: SyncBulkConsumer<Item = T, Final = F, Error = E>,
    T: Copy,
{
    type Item = T;
    type Final = F;
    type Error = E;

    async fn consume(&mut self, item: T) -> Result<(), Self::Error> {
        self.0.consume(item).await?;

        Ok(())
    }

    async fn close(&mut self, final_val: Self::Final) -> Result<(), Self::Error> {
        self.0.close(final_val).await?;

        Ok(())
    }
}

impl<C, T, F, E> BufferedConsumer for Scramble<C, T, F, E>
where
    C: SyncBulkConsumer<Item = T, Final = F, Error = E>,
    T: Copy,
{
    async fn flush(&mut self) -> Result<(), Self::Error> {
        self.0.flush().await?;

        Ok(())
    }
}

impl<C, T, F, E> BulkConsumer for Scramble<C, T, F, E>
where
    C: SyncBulkConsumer<Item = T, Final = F, Error = E>,
    T: Copy,
{
    async fn consumer_slots<'a>(
        &'a mut self,
    ) -> Result<&'a mut [MaybeUninit<Self::Item>], Self::Error>
    where
        T: 'a,
    {
        let slots = self.0.consumer_slots().await?;

        Ok(slots)
    }

    async unsafe fn did_consume(&mut self, amount: usize) -> Result<(), Self::Error> {
        self.0.did_consume(amount).await?;

        Ok(())
    }
}

impl<C, T, F, E> Scramble<C, T, F, E>
where
    C: SyncBulkConsumer<Item = T, Final = F, Error = E>,
    T: Copy,
{
    async fn perform_operation(&mut self) -> Result<(), E> {
        self.0 .0.perform_operation()?;

        Ok(())
    }
}

// To the interested reader: this implementation uses `n` only as an upper bound on how many slots
// it fills at once. A more thorough scrambler should fill *exactly* `n` slots. But this requires
// some additional state keeping (waiting until item queue has enough items) which we have not
// implemented yet. We might, though, eventually.
