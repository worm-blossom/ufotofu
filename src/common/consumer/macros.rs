//! Macros for quickly writing consumers.
//!
//! More specifically, a family of macros for wrapper consumers with an invariant wrapper and implementing various traits on the
//! resulting type by forwarding to the wrapper.
//!
//! Also, a family of macros to implement `local_nb::Consumer` by referring to an implementation of `sync::local_nb::Consumer`.
//!
//! See `common::consumer::into_slice` for example usage of all these macros.

// Macro syntax for handling generic parameters from https://stackoverflow.com/a/61189128

/// Create an opaque type of name `outer` that wraps the consumer `inner` with invariant checks.
macro_rules! invarianted_consumer_outer_type {
    ($(#[$doc:meta])* $outer:ident $inner:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? ) => {
        $(#[$doc])*
        pub struct $outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?(ufotofu::common::consumer::Invariant<$inner $(< $( $lt ),+ >)?>);
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::Consumer`.
macro_rules! invarianted_consumer_methods {
    () => {
        fn consume(&mut self, item: Self::Item) -> Result<(), Self::Error> {
            ufotofu::sync::Consumer::consume(&mut self.0, item)
        }

        fn close(&mut self, fin: Self::Final) -> Result<(), Self::Error> {
            ufotofu::sync::Consumer::close(&mut self.0, fin)
        }

        fn consume_full_slice(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<(), ufotofu::sync::ConsumeFullSliceError<Self::Error>>
            where Self::Item: Clone
        {
            ufotofu::sync::Consumer::consume_full_slice(&mut self.0, buf)
        }
    }
}

/// Implement `sync::Consumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_consumer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::sync::Consumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            $(#[$doc_item])*
            type Item = $t_item;
            $(#[$doc_final])*
            type Final = $t_final;
            $(#[$doc_error])*
            type Error = $t_error;

            invarianted_consumer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::BufferedConsmer`.
macro_rules! invarianted_buffered_consumer_methods {
    () => {
        fn flush(&mut self) -> Result<(), Self::Error> {
            ufotofu::sync::BufferedConsumer::flush(&mut self.0)
        }
    }
}

/// Implement `sync::BufferedConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_buffered_consumer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::sync::BufferedConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_buffered_consumer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `sync::BulkConsumer`.
macro_rules! invarianted_bulk_consumer_methods {
    () => {
        fn expose_slots(&mut self) -> Result<&mut [MaybeUninit<Self::Item>], Self::Error> {
            ufotofu::sync::BulkConsumer::expose_slots(&mut self.0)
        }

        unsafe fn consume_slots(&mut self, amount: usize) -> Result<(), Self::Error> {
            ufotofu::sync::BulkConsumer::consume_slots(&mut self.0, amount)
        }

        fn bulk_consume(&mut self, buf: &[Self::Item]) -> Result<usize, Self::Error> {
            ufotofu::sync::BulkConsumer::bulk_consume(&mut self.0, buf)
        }

        fn bulk_consume_full_slice(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<(), ufotofu::sync::ConsumeFullSliceError<Self::Error>> {
            ufotofu::sync::BulkConsumer::bulk_consume_full_slice(&mut self.0, buf)
        }
    }
}

/// Implement `sync::BulkConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_bulk_consumer {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::sync::BulkConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_bulk_consumer_methods!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::Consumer`.
macro_rules! invarianted_consumer_methods_local_nb {
    () => {
        async fn consume(&mut self, item: Self::Item) -> Result<(), Self::Error> {
            ufotofu::local_nb::Consumer::consume(&mut self.0, item).await
        }

        async fn close(&mut self, f: Self::Final) -> Result<(), Self::Error> {
            ufotofu::local_nb::Consumer::close(&mut self.0, f).await
        }

        async fn consume_full_slice(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<(), ufotofu::local_nb::ConsumeFullSliceError<Self::Error>>
        where
            Self::Item: Clone,
        {
            ufotofu::local_nb::Consumer::consume_full_slice(&mut self.0, buf).await
        }
    }
}

/// Implement `local_nb::Consumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_consumer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::Consumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            $(#[$doc_item])*
            type Item = $t_item;
            $(#[$doc_final])*
            type Final = $t_final;
            $(#[$doc_error])*
            type Error = $t_error;

            invarianted_consumer_methods_local_nb!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::BufferedConsmer`.
macro_rules! invarianted_buffered_consumer_methods_local_nb {
    () => {
        async fn flush(&mut self) -> Result<(), Self::Error> {
            ufotofu::local_nb::BufferedConsumer::flush(&mut self.0).await
        }
    }
}

/// Implement `local_nb::BufferedConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_buffered_consumer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BufferedConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_buffered_consumer_methods_local_nb!();
        }
    }
}

/// The method implementations of an opaque invariant wrapper around `local_nb::BulkConsmer`.
macro_rules! invarianted_bulk_consumer_methods_local_nb {
    () => {
        async fn expose_slots<'b>(
            &'b mut self,
        ) -> Result<&'b mut [MaybeUninit<Self::Item>], Self::Error>
        where
            Self::Item: 'b,
        {
            ufotofu::local_nb::BulkConsumer::expose_slots(&mut self.0).await
        }

        async unsafe fn consume_slots(&mut self, amount: usize) -> Result<(), Self::Error> {
            ufotofu::local_nb::BulkConsumer::consume_slots(&mut self.0, amount).await
        }

        async fn bulk_consume(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<usize, Self::Error> {
            ufotofu::local_nb::BulkConsumer::bulk_consume(&mut self.0, buf).await
        }

        async fn bulk_consume_full_slice(
            &mut self,
            buf: &[Self::Item],
        ) -> Result<(), ufotofu::local_nb::ConsumeFullSliceError<Self::Error>> {
            ufotofu::local_nb::BulkConsumer::bulk_consume_full_slice(&mut self.0, buf).await
        }
    }
}

/// Implement `local_nb::BulkConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_bulk_consumer_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BulkConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            invarianted_bulk_consumer_methods_local_nb!();
        }
    }
}

/// Implement both `sync::Consumer` and `local_nb::Consumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_consumer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)? $(#[$doc_item:meta])? Item $t_item:ty; $(#[$doc_final:meta])? Final $t_final:ty; $(#[$doc_error:meta])? Error $t_error:ty) => {
        invarianted_impl_consumer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $(#[$doc_item])? Item $t_item; $(#[$doc_final])? Final $t_final; $(#[$doc_error])? Error $t_error);
        invarianted_impl_consumer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)? $(#[$doc_item])? Item $t_item; $(#[$doc_final])? Final $t_final; $(#[$doc_error])? Error $t_error);
    }
}

/// Implement both `sync::BufferedConsumer` and `local_nb::BufferedConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_buffered_consumer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        invarianted_impl_buffered_consumer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
        invarianted_impl_buffered_consumer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
    }
}

/// Implement both `sync::BulkConsumer` and `local_nb::BulkConsumer` for an opaque invariant wrapper type generated by the invarianted_consumer_outer_type macro.
macro_rules! invarianted_impl_bulk_consumer_sync_and_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        invarianted_impl_bulk_consumer!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
        invarianted_impl_bulk_consumer_local_nb!($outer $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?);
    }
}

// And now for something completely different.

/// Implement `local_nb::Consumer` on a type by forwarding to its implementation of `sync::Consumer`.
macro_rules! sync_consumer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::Consumer
        for $outer
            $(< $( $lt ),+ >)? {
                type Item = <Self as ufotofu::sync::Consumer>::Item;
                type Final = <Self as ufotofu::sync::Consumer>::Final;
                type Error = <Self as ufotofu::sync::Consumer>::Error;

                async fn consume(&mut self, item: Self::Item) -> Result<(), Self::Error> {
                    ufotofu::sync::Consumer::consume(self, item)
                }

                async fn close(&mut self, f: Self::Final) -> Result<(), Self::Error> {
                    ufotofu::sync::Consumer::close(self, f)
                }

                async fn consume_full_slice(
                    &mut self,
                    buf: &[Self::Item],
                ) -> Result<(), ufotofu::local_nb::ConsumeFullSliceError<Self::Error>>
                where
                    Self::Item: Clone,
                {
                    ufotofu::sync::Consumer::consume_full_slice(self, buf)
                }
            }
    }
}

/// Implement `local_nb::BufferedConsumer` on a type by forwarding to its implementation of `sync::BufferedConsumer`.
macro_rules! sync_buffered_consumer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BufferedConsumer
        for $outer
            $(< $( $lt ),+ >)? {
                async fn flush(&mut self) -> Result<(), Self::Error> {
                    ufotofu::sync::BufferedConsumer::flush(self)
                }
            }
    }
}

/// Implement `local_nb::BulkConsumer` on a type by forwarding to its implementation of `sync::NulkConsumer`.
macro_rules! sync_bulk_consumer_as_local_nb {
    ($outer:ident $(< $( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+ >)?) => {
        impl $(< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
            ufotofu::local_nb::BulkConsumer
        for $outer
            $(< $( $lt ),+ >)?
        {
            async fn expose_slots<'b>(
                &'b mut self,
            ) -> Result<&'b mut [MaybeUninit<Self::Item>], Self::Error>
            where
                Self::Item: 'b,
            {
                ufotofu::sync::BulkConsumer::expose_slots(self)
            }

            async unsafe fn consume_slots(&mut self, amount: usize) -> Result<(), Self::Error> {
                ufotofu::sync::BulkConsumer::consume_slots(self, amount)
            }

            async fn bulk_consume(
                &mut self,
                buf: &[Self::Item],
            ) -> Result<usize, Self::Error> {
                ufotofu::sync::BulkConsumer::bulk_consume(self, buf)
            }
    
            async fn bulk_consume_full_slice(
                &mut self,
                buf: &[Self::Item],
            ) -> Result<(), ufotofu::local_nb::ConsumeFullSliceError<Self::Error>> {
                ufotofu::sync::BulkConsumer::bulk_consume_full_slice(self, buf)
            }
        }
    }
}
